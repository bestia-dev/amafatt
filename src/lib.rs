//! **amafatt - processes the data from Amazon txt file and send an api json request to FattureInCloud.it**  
//
// region: lmake_readme include "readme_IT.md" //! A
//! # amafatt
//!
//! version: 19.9.10  
//! Una applicazione prototipo per inserire dati ricevuti da Amazon in formato txt nella API di FattureInCloud.it.  
//! Max sa cosa vuole dalla applicazione ed io (Luciano) costruirò la app come prototipo.  
//! Dopo si vedrà se saremmo contenti con il risultato e si andrà avanti.  
//! ## FattureInCloud.it
//! Ho creato un nuovo account per bestia.dev dove si può sperimentare.  
//! Io e Max abbiamo accesso a questo account e possiamo collaborare.  
//! La documentazione della API e qui:  
//! https://api.FattureInCloud.it/v1/documentation/dist/#!/Richiesta_generica/jsonrequest  
//! La lingua di tutti i programmatori e l'Inglese e per questo ci sarà tanto inglese nella source code.  
//! La source code e disponibile sul mio GitHub privato https://github.com/bestia-dev/amafatt solo per i collaboratori.  
//!
// endregion: lmake_readme include "readme_IT.md" //! A
//
//
// region: lmake_readme include "readme.md" //! A
//!
//! ## Documentation
//! Documentation generated from source code:  
//! https://bestia-dev.github.io/amafatt/index.html
//!
//! ## Rust, Wasm, Dodrio
//! The programming language of this application is not important.  
//! It is easy to rewrite the application in any other language if necessary.  
//! The important thing is the application logic and mapping of data.  
//! I will create the prototype in the Rust programming language. It will be
//! compiled in Wasm/WebAssembly that runs inside all modern browsers.  
//! The GUI interface will be in simple HTML updated with Dodrio Virtual Dom.  
//! There will not be necessary any special servers, JavaScript, npm, web-pack
//! or complicated css and html.  
//!
//! ## Development environment
//! Install the rust toolchain from  
//! https://www.rust-lang.org/tools/install.  
//! For wasm workflow tool installation on Windows:  
//! https://rustwasm.github.io/wasm-pack/installer/  
//! You will need also a simple static file server:  
//! `cargo install basic-http-server`  
//! ## Source
//! Absolutely everything manually coded is in Rust language in the folder `/src/`.  
//! No manual JavaScript or HTML needed.  
//! The index.html file is a simple template.  
//! The pkg/mem.js file is generated by wasm-bindgen on building.  
//! I prepared a small simple css with css grid for styling based on w3.css.   
//! No need for npm or web-pack.  
//! The proper way to do json would be with structs and vectors, but it is so much typing and retyping of datatypes and input fields - for small benefit. I will use whole json as a string. And there replace what should be replaced. Much simpler that way for this project. Even json objects are too complicated. I will use all that as simple strings.  
//! ## Make
//! I prepared all the needed tasks/flows in cargo make.  
//! https://github.com/sagiegurari/cargo-make  
//! Install it simply with `cargo install --force cargo-make`  
//! `cargo make` - lists the possible available/public flows/tasks  
//! `cargo make dev` - builds the development version and runs the server and the browser  
//! `cargo make release` - builds the release version and runs the server and the browser  
//! The make script also lunches the `basic-http-server`and open the browser.  
//! To copy the content of readme.md files into doc comments of *.rs files I created this utility:  
//! https://github.com/bestia-dev/lmake_readme  
//! `cargo make doc` - prepare the doc comments and creates the docs folder  
//! TODO: could make a flow to publish to GitHub or to google vm or a task for increment version numbers.  
//! ## Workflow
//! There is only one screen with big text fields for request and response from FattureInCloud.it.  
//! A menu will have buttons to create different requests.  
//! For importing data from Amazon there will be another text field where to copy/paste the content of the txt file from Amazon. No file uploads here because we don't really need/have a server.  
//! The button Extract order-id will create a vector of order-id in case there are multiples in the amazon txt. For every order-id there will be a new button to process the txt and create a json string as close as possible what the API needs. That json data is possible to manually edit if needed.  
//! The button `Send json` sends the json request to the API and fetch the response into the response field. Only one order-id should be sent at a time.   
//! After that all needed editing, deleting, changing is made through the FattureInCloud.it user interface.  
//! TODO: after some time it can be modified to send all the order-id one by one automatically.
//! ## reverse proxy  
//! Modern browsers don't allow cross origin fetch by default.  
//! The server must allow it explicitly with a special header `Access-Control-Allow-Origin=*`.  
//! As expected, the site FattureInCloud.it does not send this header.  
//! I wrote them to correct this, but I don't have any hope they will listen to me.  
//! The workaround is a reverse proxy that receives the original request,
//! sends it to FattureInCloud.it, receives the response, add this special header
//! and sends the response back to the browser.
//! I use nginx on my google cloud vm. To achieve this I added this lines
//! in the configuration file \etc\nginx\sites-available\default:  
//! ```
//! 	#region amafatt
//! 		# example https://api.FattureInCloud.it/v1/richiesta/info
//!
//! 		# the trailing / after both of these lines means this route is not appended to the forwarding
//! 		location /v1/ {
//! 			proxy_pass https://api.FattureInCloud.it/v1/;
//! 			proxy_buffering off;
//! 			add_header  Access-Control-Allow-Origin *;
//! 		}
//! 	#endregion
//! ```
//! All the requests will be now sent to https://bestia.dev/v1/.  
//!
//! ## Reference
//! https://github.com/rustwasm/wasm-bindgen/tree/master/examples/fetch  
//! https://api.FattureInCloud.it/v1/documentation/dist/#!/Richiesta_generica/jsonrequest  
//!

// endregion: lmake_readme include "readme.md" //! A
//

//region: Clippy
#![warn(
    clippy::all,
    clippy::restriction,
    clippy::pedantic,
    clippy::nursery,
    clippy::cargo,
    //variable shadowing is idiomatic to Rust, but unnatural to me.
    clippy::shadow_reuse,
    clippy::shadow_same,
    clippy::shadow_unrelated,

)]
#![allow(
    //library from dependencies have this clippy warnings. Not my code.
    //Why is this bad: It will be more difficult for users to discover the purpose of the crate, 
    //and key information related to it.
    clippy::cargo_common_metadata,
    //Why is this bad : This bloats the size of targets, and can lead to confusing error messages when 
    //structs or traits are used interchangeably between different versions of a crate.
    clippy::multiple_crate_versions,
    //Why is this bad : As the edition guide says, it is highly unlikely that you work with any possible 
    //version of your dependency, and wildcard dependencies would cause unnecessary 
    //breakage in the ecosystem.
    clippy::wildcard_dependencies,
    //Rust is more idiomatic without return statement
    //Why is this bad : Actually omitting the return keyword is idiomatic Rust code. 
    //Programmers coming from other languages might prefer the expressiveness of return. 
    //It’s possible to miss the last returning statement because the only difference 
    //is a missing ;. Especially in bigger code with multiple return paths having a 
    //return keyword makes it easier to find the corresponding statements.
    clippy::implicit_return,
    //I have private function inside a function. Self does not work there.
    //Why is this bad: Unnecessary repetition. Mixed use of Self and struct name feels inconsistent.
    clippy::use_self,
    //Cannot add #[inline] to the start function with #[wasm_bindgen(start)]
    //because then wasm-pack build --target web returns an error: export run not found 
    //Why is this bad: In general, it is not. Functions can be inlined across crates when that’s profitable 
    //as long as any form of LTO is used. When LTO is disabled, functions that are not #[inline] 
    //cannot be inlined across crates. Certain types of crates might intend for most of the 
    //methods in their public API to be able to be inlined across crates even when LTO is disabled. 
    //For these types of crates, enabling this lint might make sense. It allows the crate to 
    //require all exported methods to be #[inline] by default, and then opt out for specific 
    //methods where this might not make sense.
    clippy::missing_inline_in_public_items,
    //Why is this bad: This is only checked against overflow in debug builds. In some applications one wants explicitly checked, wrapping or saturating arithmetic.
    //clippy::integer_arithmetic,
    //Why is this bad: For some embedded systems or kernel development, it can be useful to rule out floating-point numbers.
    clippy::float_arithmetic,
    //Why is this bad : Doc is good. rustc has a MISSING_DOCS allowed-by-default lint for public members, but has no way to enforce documentation of private items. This lint fixes that.
    clippy::doc_markdown,
    //Why is this bad : Splitting the implementation of a type makes the code harder to navigate.
    clippy::multiple_inherent_impl,

    clippy::missing_docs_in_private_items,
)]
//endregion

//region: extern and use statements
//needed for dodrio! macro (typed-html)
#![recursion_limit = "5012"]
//rust modules system
mod fetchmod;
mod reqbodymod;
mod rootrenderingmod;
mod amazonmod;
mod isocountriesmod;
mod credentialsmod;

extern crate console_error_panic_hook;
extern crate log;
extern crate serde;
//#[macro_use]
extern crate serde_derive;
extern crate serde_json;
extern crate web_sys;
#[macro_use]
extern crate unwrap;
extern crate wasm_bindgen_futures;

use wasm_bindgen::prelude::wasm_bindgen;
use web_sys::{console};
use wasm_bindgen::JsValue;
//endregion

///this is the start function that wasm_bindgen calls
#[wasm_bindgen(start)]
pub fn wasm_bindgen_start() {
    // Initialize debugging for when/if something goes wrong.
    console_error_panic_hook::set_once();

    // Get the div for rendering html inside
    let window = unwrap!(web_sys::window());
    let document = unwrap!(window.document());
    let div_for_virtual_dom = unwrap!(
        document.get_element_by_id("div_for_virtual_dom"),
        "No #div_for_virtual_dom"
    );

    // Construct a new rendering component.
    let rrc = rootrenderingmod::RootRenderingComponent::new();

    // Mount the component to the div
    let vdom = dodrio::Vdom::new(&div_for_virtual_dom, rrc);

    // Run the component forever. Never drop the memory. Practically a memory leak.
    vdom.forget();
}

//region: Helper functions
///simple console write with a string
fn log1(x: &str) {
    console::log_1(&JsValue::from_str(x));
}
//endregion
